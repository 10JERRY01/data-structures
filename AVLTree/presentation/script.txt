

Hello!

Welcome back, today i'm going to introduce probably one of the most important types of trees in computer science which are Balanced Binary Search Trees. 

BBSTs are very different from BSTs because they not only conform the BST tree invariant but are also balanced. What I mean by balanced is that they are self-adjusting to maintain a logarithmic height in proportion to the number of nodes they hold. This is very important because it keeps operations such as insertion and deletions blazing fast because the tree is much more squashed.

In terms of complexity, a BST has average logarithmic operations which is quite good. However, the worst case still remains linear because the tree could degrade into a chain for some inputs. One such input is a sequence of increasing numbers. To avoid this linear complexity we've invented BBST.

The worst case logarithmic property of BBST is what makes them really appealing.

Central to how nearly all BBST implementations keep themselves balanced is the concept of tree rotations which is going to be the main topic of this video. Later we'll actually look at some specific types of BBST such as the AVL tree to see how they work.

So, the secret ingredient to most BBST implementations in the combination of two things. A clever tree invariant and tree rotations. 
A tree invariant is a property/rule you impose on your tree that it must meet after every operation. To ensure that the invariant is always satisfied a series of tree rotations are normally applied. We'll get back to this concept of invariants in a later video don't worry about it for now.

Let's look at how tree rotations work. Suppose our invariant is not satisfied and to fix it we need to do a right rotation about node A. Assuming node A has a left child B we can perform a right rotation to put B where node A was and push node A down to become B's right child. 
When I first learnt about this in my undergrad I was mind-blow, literally! I thought it was absurd or even to the point of being illegal that you should be allowed to do this and just move around nodes in your tree. 
But what i've realized since then is that a transformation like this is totally legitimate since we're not breaking the BST invariant. 
If you inspect the right tree you'll discover that in terms of ordering and placement, node D is < node B is less then E is less than A is less than C. Then you inspect the left tree and remark that this is also true.

A bit more detail on why performing tree rotations is a valid operation. First you have to remember that all BBSTs are BST, meaning that the BST invariant holds, so for every node n, the values in the left subtree are less than the value in n and the values in the right subtree are all greater than the value in n.
So in this sense, it doesn't matter what the tree structure itself looks like, all that fundamentally matters is that the BST invariant holds. This means we can shuffle/transform/rotate the values and nodes in the tree as we please as long as the BST invariant remains satisfied! 

Now, let's look some how these tree rotations are done in great detail. For simplicity, since the rotations are symmetric I will only do the right rotation and you should be able to figure out the left rotation on your own.
First have a look at the tree on the right. Notice that there are directed edges pointing downwards and another node P above A which may or may not exist, this is why there's a dotted line on that edge. If node A does have a parent node P, then it is important that we take it into account when doing the rotation.

In either case, we start with a pointer reference to node A, this is what the orange arrow is. 

Then we'll want a pointer to node B.

After that set A's left pointer to point to B's right child.

Then change B's right pointer to point to A and we've successfully done a right rotations, woohoo! If we rearrange the nodes this is what we'd end up with.

**press**

However, notice that there's a slight problem, if node A had a parent node then one of the parent's left or right pointer would still be referencing A. this is problematic since B is A's successor after the rotation. 

So we change that link to now point to B. This step is usually done on the recursive callback using the return value of the rightRotate function.


We just finished looking at the case where each node has a reference to the left and right child nodes, but in some BBST implementations it's more convenient for nodes to also have a reference to the parent ndoe. This complicates tree rotations because now instead of updating three pointers we need to update six pointers, let's have a look.

So in the case, where we also have the parent link every node is doubly linked. We start off with a pointer referencing node A and the first thing we'll want to do is also reference node B and P so we don't lose them as we shuffle pointers.

Next, we'll adjust the left subtree of node A, so make A's left pointer reference B's right subtree. Of course throughout this example assume B's not null, if you're paranoid you can add an extra if statement to check this.

But it would be a mistake to assume B's right subtree is not null, we actually have to check against this before setting B's right child's parent to reference A.

Next let's make A the right subtree of B. Set B's right point to reference A.

Now make A's parent pointer reference A.

The last thing we need to do is adjust the reference to the Parent node P. So make B's parent pointer reference P.

The very last thing to do make P's left or right pointer reference the successor node B. Notice that we need to check if P is not null because it might node exist.

If we readjust the tree we'll see that we correctly did a right rotation.

There are a lot of steps to doing this right rotation. It's a very error prone process which is why I wanted to do it in such detail.

In the next video we'll look at how tree rotations are used when inserting nodes into an AVL tree. If you learned something please like this video and subscribe for more mathematics and computer science videos.


===========================================================================

Hello!

Today we're going to be looking at how to insert nodes into an AVL tree in great detail. We'll be making use of the tree rotation technique we looked at in the last video, so if you didn't watch that video make such you rollback one video.

Alright, before we get too far I should mention what an AVL tree is. An AVL tree is one of many types of BBSTs which all for logarithmic insertion, deletion and search operations.
Something really special about the AVL tree is that it was the first type of BBST to be discovered, and then soon after a whole bunch of other BBSTs started to emerge including the 2-3 tree, the AA tree, the scapegoat tree and the AVL tree's main rival the red black tree to name a few.

What you need to know about next is the property that keeps the AVL tree balanced, and this is the balance factor. Simply put, the balance factor of a node is the difference between the height of the right subtree and the left subtree.
I'm pretty such the balance factor can also be computed as left subtree height minus the right subtree height, but don't quote me on that. It would also screw up a lot of what I'm about to say, and may also be the reason why you'll find inconsistent ideas about what way to do tree rotations on various google results, so for consistency let's keep the balance factor right subtree height minus left subtree height.
For clarity, because people do get this wrong or define it differently, the height of a node x is calculated as the number of edges between x and the furthest leaf. So, if your tree only has one node, the tree has height 0, not height 1 because there are no edges.
The invariant on the AVL that keep it balanced it forcing the balance factor of every node to be either -1, 0 or +1. If the balance factor of a node is anything else we need to resolve that with tree rotations.

In terms of information we need to store in each node to actually make the AVL tree work what we'll need is the actual value the node stores. You must make sure this value is comparable so we know how to insert it and in what position it goes in the tree. Then we'll also need to store the balance factor and height of the node as well as the left and right child pointers. So as the algorithm executes we'll need to update all these values except for the node's actual value, so keep that in mind.

So a slide back or so I said that the balance factor of a node must always be -1, 0 or +1. A natural question to ask is how to we handle the case where that's not true? The answer is that when this is not true the BF is either +2 or -2 which we can easily handle with tree rotations. The rotations we need to perform depending on the structure of the tree can be broken down into four distinct cases.
The first such case is when the tree is left heavy and there are two left children. This is an easy case to fix because all we need to do is to perform a right rotation about the yellow node to balance.

The next case is the left-right case where you have a left child but then that node has a right child. To fix this you do a left rotation about left child node, so the green one in the leftmost image. What then happens is that this transforms that case into the left-left case we just saw which we can solve with a right rotation to balance.

The third case is the right-right case which is symmetric to the left-left case, so instead of doing a right rotation we do a left rotation about the green node.

Last but not least is the right-left case which is symmetric to the left-right case. For this case you would perform a right rotation about the yellow node on the left most image to transform this case into the right-right case and then do a left rotation about the green node on the middle image.

Next I want to show you some pseudocode for inserting elements with an AVL tree. This first method is the public facing insert method which returns true or false depending on whether the value was successfully inserted. For simplicity we're going to ban duplicate values in our AVL tree. So if the value already exists or the value is null this method returns false.
If the node is not null and it doesn't already exist in the tree we call our private recursive insert method where we pass in a pointer to the root node and the value we want to insert.

The private recursive method is also simple, if we hit the base case, a null node we simply return a new instance of a node with the value we want to insert, otherwise we get our comparator value so we can decide if the node should go in the left or the right subtree. After that on the recursive callback we call the update method which update the balance factor and height values, and lastly we rebalance the tree with the balance method. Now let's take a closer look at what the update and balance methods are actually doing.

The update method updates the balance factor and height values of our node. So, to calculate the height of the node we get the maximum height of the left and the right subtrees and add one. Notice that I initialize the left and right subtree heights to be -1 because this will cancel out with the +1 with the max function in the case where the node has no subtrees giving a correct height of 0 for leaf nodes. Then lastly I update the balance factor for this node by finding the difference between the right subtree and the left subtree.

The balance method is slightly more involved, but not too crazy. Here we check if our balance factor has an illegal value of either -2 or +2. If the balance factor is -2 then we know that the node is left heavy, then we dig further into the left subtree to determine if we're dealing with a left-left case or a left-right case. We do a similar thing if the balance factor is +2 except we're dealing with the right-right or right-left case. If the balance factor is not +2 or -2 then we know that the balance factor is either +1, 0 or -1 and in either case we don't need to do anything.

Inside the four cases we might run into you notice that all we have here are calls to the leftRotation and rightRotation methods that we saw in the last video. Also notice that the left-right and right-left cases call the leftLeftCase and rightRightCase method respectively since they reduce to those cases after a first rotation.

In the last video we looked at this right rotation method, but since we're dealing with an AVL tree in this video we actually need to augment that method to update the heights and balance factor of the nodes we're moving around when we do the rotations. This is a subtle detail you must not forget otherwise your height and balance factor values will be inconsistent. the left rotation case is symmetric to this one, you should be able to figure it out pretty easily.































