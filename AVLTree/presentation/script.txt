

Hello!

Welcome back, today i'm going to introduce probably one of the most important types of trees in computer science which are Balanced Binary Search Trees. 

BBSTs are very different from BSTs because they not only conform the BST tree invariant but are also balanced. What I mean by balanced is that they are self-adjusting to maintain a logarithmic height in proportion to the number of nodes they hold. This is very important because it keeps operations such as insertion and deletions blazing fast because the tree is much more squashed.

In terms of complexity, a BST has average logarithmic operations which is quite good. However, the worst case still remains linear because the tree could degrade into a chain for some inputs. One such input is a sequence of increasing numbers. To avoid this linear complexity we've invented BBST.

The worst case logarithmic property of BBST is what makes them really appealing.

Central to how nearly all BBST implementations keep themselves balanced is the concept of tree rotations which is going to be the main topic of this video. Later we'll actually look at some specific types of BBST such as the AVL tree to see how they work.

So, the secret ingredient to most BBST implementations in the combination of two things. A clever tree invariant and tree rotations. 
A tree invariant is a property/rule you impose on your tree that it must meet after every operation. To ensure that the invariant is always satisfied a series of tree rotations are normally applied. We'll get back to this concept of invariants in a later video don't worry about it for now.

Let's look at how tree rotations work. Suppose our invariant is not satisfied and to fix it we need to do a right rotation about node A. Assuming node A has a left child B we can perform a right rotation to put B where node A was and push node A down to become B's right child. 
When I first learnt about this in my undergrad I was mind-blow, literally! I thought it was absurd or even to the point of being illegal that you should be allowed to do this and just move around nodes in your tree. 
But what i've realized since then is that a transformation like this is totally legitimate since we're not breaking the BST invariant. 
If you inspect the right tree you'll discover that in terms of ordering and placement, node D is < node B is less then E is less than A is less than C. Then you inspect the left tree and remark that this is also true.

A bit more detail on why performing tree rotations is a valid operation. First you have to remember that all BBSTs are BST, meaning that the BST invariant holds, so for every node n, the values in the left subtree are less than the value in n and the values in the right subtree are all greater than the value in n.
So in this sense, it doesn't matter what the tree structure itself looks like, all that fundamentally matters is that the BST invariant holds. This means we can shuffle/transform/rotate the values and nodes in the tree as we please as long as the BST invariant remains satisfied! 

Now, let's look some how these tree rotations are done in great detail. For simplicity, since the rotations are symmetric I will only do the right rotation and you should be able to figure out the left rotation on your own.
First have a look at the tree on the right. Notice that there are directed edges pointing downwards and another node P above A which may or may not exist, this is why there's a dotted line on that edge. If node A does have a parent node P, then it is important that we take it into account when doing the rotation.

In either case, we start with a pointer reference to node A, this is what the orange arrow is. 

Then we'll want a pointer to node B.

After that set A's left pointer to point to B's right child.

Then change B's right pointer to point to A and we've successfully done a right rotations, woohoo! If we rearrange the nodes this is what we'd end up with.

**press**

However, notice that there's a slight problem, if node A had a parent node then one of the parent's left or right pointer would still be referencing A. this is problematic since B is A's successor after the rotation. 

So we change that link to now point to B. This step is usually done on the recursive callback using the return value of the rightRotate function.


We just finished looking at the case where each node has a reference to the left and right child nodes, but in some BBST implementations it's more convenient for nodes to also have a reference to the parent ndoe. This complicates tree rotations because now instead of updating three pointers we need to update six pointers, let's have a look.

So in the case, where we also have the parent link every node is doubly linked. We start off with a pointer referencing node A and the first thing we'll want to do is also reference node B and P so we don't lose them as we shuffle pointers.

Next, we'll adjust the left subtree of node A, so make A's left pointer reference B's right subtree. Of course throughout this example assume B's not null, if you're paranoid you can add an extra if statement to check this.

But it would be a mistake to assume B's right subtree is not null, we actually have to check against this before setting B's right child's parent to reference A.

Next let's make A the right subtree of B. Set B's right point to reference A.

Now make A's parent pointer reference A.

The last thing we need to do is adjust the reference to the Parent node P. So make B's parent pointer reference P.

The very last thing to do make P's left or right pointer reference the successor node B. Notice that we need to check if P is not null because it might node exist.

If we readjust the tree we'll see that we correctly did a right rotation.

There are a lot of steps to doing this right rotation. It's a very error prone process which is why I wanted to do it in such detail.

In the next video we'll look at how tree rotations are used when inserting nodes into an AVL tree. If you learned something please like this video and subscribe for more mathematics and computer science videos.


===========================================================================

Hello!

Today we're going to be looking at how to insert nodes into an AVL tree in great detail. We'll be making use of the tree rotation technique we looked at in the last video, so if you didn't watch that video make such you rollback one video.

Alright, before we get too far I should mention what an AVL tree is. An AVL tree is one of many types of BBSTs which all for logarithmic insertion, deletion and search operations.
Something really special about the AVL tree is that it was the first type of BBST to be discovered, and then soon after a whole bunch of other BBSTs started to emerge including the 2-3 tree, the AA tree, the scapegoat tree and the AVL tree's main rival the red black tree to name a few.

What you need to know about next is the property that keeps the AVL tree balanced, and this is the balance factor. Simply put, the balance factor of a node is the difference between the height of the right subtree and the left subtree.
I'm pretty such the balance factor can also be computed as left subtree height minus the right subtree height, but don't quote me on that. It would also screw up a lot of what I'm about to say, and may also be the reason why you'll find inconsistent ideas about what way to do tree rotations on various google results, so for consistency let's keep the balance factor right subtree height minus left subtree height.
For clarity, because people do get this wrong or define it differently, the height of a node x is calculated as the number of edges between x and the furthest leaf. So, if your tree only has one node, the tree has height 0, not height 1 because there are no edges.
The invariant on the AVL that keep it balanced it forcing the balance factor of every node to be either -1, 0 or +1. If the balance factor of a node is anything else we need to resolve that with tree rotations.



































